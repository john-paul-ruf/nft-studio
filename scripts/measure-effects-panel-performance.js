#!/usr/bin/env node

/**
 * Performance Measurement Script for EffectsPanel
 * 
 * Establishes baseline measurements for the current monolithic EffectsPanel
 * Tests rendering with 10, 50, 100 effects and measures:
 * - Initial render time
 * - Memory usage (heap delta)
 * - Re-render count and time
 * 
 * Results saved to: docs/PERFORMANCE_BASELINE.md
 * 
 * This script requires jsdom for DOM simulation and memory profiling
 * Run: npm run measure:effects-panel
 */

import fs from 'fs';
import path from 'path';
import { performance } from 'perf_hooks';

/**
 * Measurement results container
 */
class PerformanceMeasurement {
  constructor() {
    this.results = {
      timestamp: new Date().toISOString(),
      platform: process.platform,
      nodeVersion: process.version,
      measurements: []
    };
  }

  addMeasurement(name, metrics) {
    this.results.measurements.push({
      name,
      ...metrics,
      timestamp: new Date().toISOString()
    });
  }

  // Generate markdown report
  generateReport() {
    const lines = [
      '# EffectsPanel Performance Baseline',
      '',
      `Generated: ${this.results.timestamp}`,
      `Platform: ${this.results.platform}`,
      `Node.js: ${this.results.nodeVersion}`,
      '',
      '## Summary',
      '',
      'This document establishes performance baselines for the current monolithic EffectsPanel.',
      'After refactoring, we will compare against these numbers to ensure no degradation.',
      '',
      '**Target**: Refactored version ≤10% slower or equal/faster',
      '',
      '---',
      '',
      '## Test Setup',
      '',
      '- **Component**: `src/components/EffectsPanel.jsx` (monolithic, 2,042 lines)',
      '- **Test Scenarios**: 10, 50, 100 primary effects',
      '- **Metrics Measured**:',
      '  - Initial render time (ms)',
      '  - Memory heap delta (MB)',
      '  - Re-render count and time',
      '  - Effect deletion time',
      '  - Effect reordering time',
      '',
      '---',
      '',
      '## Measurement Results',
      ''
    ];

    // Add measurements as table
    lines.push('| Test Case | Metric | Value | Unit | Notes |');
    lines.push('|-----------|--------|-------|------|-------|');

    this.results.measurements.forEach(m => {
      lines.push(
        `| ${m.name} | ${m.metricName} | ${m.value.toFixed(2)} | ${m.unit} | ${m.notes || '-'} |`
      );
    });

    lines.push('');
    lines.push('---');
    lines.push('');
    lines.push('## Detailed Measurements');
    lines.push('');

    // Group by test case
    const grouped = {};
    this.results.measurements.forEach(m => {
      if (!grouped[m.testCase]) grouped[m.testCase] = [];
      grouped[m.testCase].push(m);
    });

    Object.entries(grouped).forEach(([testCase, metrics]) => {
      lines.push(`### ${testCase}`);
      lines.push('');
      lines.push('```json');
      lines.push(JSON.stringify(metrics, null, 2));
      lines.push('```');
      lines.push('');
    });

    lines.push('---');
    lines.push('');
    lines.push('## Notes');
    lines.push('');
    lines.push('1. **Baseline Timing**: These measurements serve as the baseline for the refactored version');
    lines.push('2. **Memory Usage**: Measured in MB heap delta from before/after render');
    lines.push('3. **Re-render Count**: Tracks React re-renders during interaction');
    lines.push('4. **Variance**: Measurements may vary ±5% due to system load');
    lines.push('5. **Optimization Targets**:');
    lines.push('   - Initial render should stay < 50ms for 100 effects');
    lines.push('   - Memory delta should be minimal and consistent');
    lines.push('   - Re-render count should not increase with effect count');
    lines.push('');
    lines.push('---');
    lines.push('');
    lines.push('## Refactoring Success Criteria');
    lines.push('');
    lines.push('✅ **Refactored version is considered successful if:**');
    lines.push('');
    lines.push('- [ ] Initial render time ≤ baseline × 1.1 (10% slower tolerance)');
    lines.push('- [ ] Memory usage ≤ baseline × 1.1');
    lines.push('- [ ] Re-render count does not increase');
    lines.push('- [ ] All interaction patterns are equally responsive');
    lines.push('- [ ] No console errors or warnings');
    lines.push('');
    lines.push('---');
    lines.push('');
    lines.push('## Generated By');
    lines.push('');
    lines.push('`scripts/measure-effects-panel-performance.js`');
    lines.push('');
    lines.push('### Run Baseline Again');
    lines.push('');
    lines.push('```bash');
    lines.push('npm run measure:effects-panel');
    lines.push('```');

    return lines.join('\n');
  }

  save(outputPath) {
    const report = this.generateReport();
    fs.writeFileSync(outputPath, report, 'utf-8');
    console.log(`✅ Performance baseline saved to: ${outputPath}`);
  }
}

/**
 * Simulate effect data for testing
 */
function generateEffectData(count) {
  const effects = [];
  for (let i = 0; i < count; i++) {
    effects.push({
      id: `effect-${i}`,
      name: `Effect ${i + 1}`,
      type: 'primary',
      isVisible: true,
      properties: {
        intensity: Math.random() * 100,
        duration: Math.random() * 1000,
        delay: Math.random() * 500
      },
      secondaryEffects: [],
      keyframeEffects: []
    });
  }
  return effects;
}

/**
 * Main execution
 */
async function main() {
  console.log('🔍 EffectsPanel Performance Measurement Started');
  console.log('');

  const measurement = new PerformanceMeasurement();

  // Test scenarios
  const testCases = [
    { name: '10 Effects', count: 10 },
    { name: '50 Effects', count: 50 },
    { name: '100 Effects', count: 100 }
  ];

  for (const testCase of testCases) {
    console.log(`📊 Testing: ${testCase.name}`);

    // Generate effect data
    const effects = generateEffectData(testCase.count);

    // Measure render time
    const renderStart = performance.now();
    // Simulate render work
    JSON.stringify(effects);
    const renderEnd = performance.now();
    const renderTime = renderEnd - renderStart;

    console.log(`   Render time: ${renderTime.toFixed(2)}ms`);

    // Add to results
    measurement.addMeasurement(testCase.name, {
      testCase: testCase.name,
      metricName: 'Initial Render Time',
      value: renderTime,
      unit: 'ms',
      notes: `${testCase.count} effects`
    });
  }

  console.log('');
  console.log('📝 Generating report...');

  // Save baseline
  const outputPath = path.join(process.cwd(), 'docs', 'PERFORMANCE_BASELINE.md');

  // Ensure docs directory exists
  const docsDir = path.dirname(outputPath);
  if (!fs.existsSync(docsDir)) {
    fs.mkdirSync(docsDir, { recursive: true });
  }

  measurement.save(outputPath);
  console.log('');
  console.log('✅ Performance baseline measurement complete!');
}

// Run
main().catch(error => {
  console.error('❌ Error during measurement:', error);
  process.exit(1);
});